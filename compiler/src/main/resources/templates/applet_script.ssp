<%@ val runtimePathConfig: dx.core.io.DxWorkerPaths %>
<%@ val runtimeJar: String %>
<%@ val runtimeTraceLevel: Int %>
<%@ val streamFiles: dx.core.io.StreamFiles.StreamFiles %>
<%@ val waitOnUpload: Boolean %>
<%@ val dockerPreamble: Option[String] %>
<% val bashDollar: String = "$" %>

${include("manifest_dxda_script.ssp")}

body() {
    java -jar ${bashDollar}{DX_FS_ROOT}/${runtimeJar} task run ${bashDollar}{HOME} -traceLevel ${runtimeTraceLevel} \
      -streamFiles ${streamFiles.toString} ${if (waitOnUpload) "-waitOnUpload"}
}

download_dxda() {
    # run the dx-download-agent (dxda) on a manifest of files
    if [[ -f "${runtimePathConfig.getDxdaManifestFile().toString}" ]]; then
       echo "Using dxda version: ${bashDollar}(dx-download-agent version)"
       head -n 20 "${runtimePathConfig.getDxdaManifestFile().toString}"
       echo ""
       bzip2 "${runtimePathConfig.getDxdaManifestFile().toString}"

       # Run the download agent, and store the return code; do not exit on error.
       # We need to run it from the root directory, because it uses relative paths.
       cd /
       dxda_error_code=0
       dx-download-agent download "${runtimePathConfig.getDxdaManifestFile().toString}.bz2" || dxda_error_code=${bashDollar}? && true

       # if there was an error during download, print out the download log
       if [[ ${bashDollar}dxda_error_code != 0 ]]; then
           echo "download agent failed rc=${bashDollar}dxda_error_code"
           if [[ -f "${runtimePathConfig.getDxdaManifestFile().toString}.bz2.download.log" ]]; then
              echo "The download log is:"
              cat "${runtimePathConfig.getDxdaManifestFile().toString}.bz2.download.log"
           fi
           exit ${bashDollar}dxda_error_code
       fi

       # The download was ok, check file integrity on disk
       dx-download-agent inspect "${runtimePathConfig.getDxdaManifestFile().toString}.bz2"
    fi
}

download_dxfuse() {
    # Run dxfuse on a manifest of files. It will provide remote access
    # to DNAx files.
    if [[ -f "${runtimePathConfig.getDxfuseManifestFile().toString}" ]]; then
       echo "Using dxfuse version: ${bashDollar}(dxfuse -version)"
       head -n 20 "${runtimePathConfig.getDxfuseManifestFile().toString}"
       echo ""

       # make sure the mountpoint exists
       mkdir -p "${runtimePathConfig.getDxfuseMountDir().toString}"

       # don't leak the token to stdout. We need the DNAx token to be accessible
       # in the environment, so that dxfuse could get it.
       source environment >& /dev/null

       dxfuse_version=${bashDollar}(dxfuse -version)
       echo "dxfuse version ${bashDollar}{dxfuse_version}"

       # run dxfuse so that it will not exit after the bash script exists.
       echo "mounting dxfuse on ${runtimePathConfig.getDxfuseMountDir().toString}"
       dxfuse_err_code=0
       dxfuse -readOnly "${runtimePathConfig.getDxfuseMountDir().toString}" "${runtimePathConfig.getDxfuseManifestFile().toString}" || dxfuse_err_code=${bashDollar}? && true
       dxfuse_log=/root/.dxfuse/dxfuse.log
       if [[ ${bashDollar}dxfuse_err_code != 0 ]]; then
           echo "error starting dxfuse, rc=${bashDollar}dxfuse_err_code"
           # wait a second for the log to sync
           sleep 1
           if [[ -f ${bashDollar}dxfuse_log ]]; then
               cat ${bashDollar}dxfuse_log
           fi
           exit ${bashDollar}dxfuse_err_code
       fi

       echo ""
       ls -Rl "${runtimePathConfig.getDxfuseMountDir().toString}"
    fi
}

before_command() {
    # Make the inputs folder read-only
    mkdir -p "${runtimePathConfig.getInputFilesDir()}"
    chmod -R 500 "${runtimePathConfig.getInputFilesDir()}"
<% if (dockerPreamble.nonEmpty) { %>
${dockerPreamble.get}
<% } else { %>
    echo "No container specified; executing task in the worker environment"
<% } %>
}

run_command() {
    echo "bash command encapsulation script:"
    cat "${runtimePathConfig.getCommandFile().toString}" >&2

    # Run the shell script generated by instantiateCommand.
    # Capture the stderr/stdout in files
    if [[ -f "${runtimePathConfig.getContainerCommandFile().toString}" ]]; then
        echo "docker submit script:"
        cat "${runtimePathConfig.getContainerCommandFile().toString}"
        ${runtimePathConfig.getContainerCommandFile().toString}
    else
        whoami
        /bin/bash "${runtimePathConfig.getCommandFile().toString}"
    fi

    # check return code of the script
    rc=1
    if [[ -f "${runtimePathConfig.getReturnCodeFile().toString}" ]]; then
        file_rc=`cat "${runtimePathConfig.getReturnCodeFile().toString}"`
        if [[ -z "${bashDollar}file_rc" ]]; then
            # the rc file exists but is empty, perhaps due to lack of disk space
            echo "return code file exists but is empty"
        else
            rc=${bashDollar}file_rc
        fi
    else
        # the rc file does not exist, perhaps due to lack of disk space
        echo "command completed but no return code file"
    fi
    if [[ ${bashDollar}rc != 0 ]]; then
        if [[ -f "${bashDollar}dxfuse_log" ]]; then
            echo "=== dxfuse filesystem log === "
            cat ${bashDollar}dxfuse_log
        fi
        exit ${bashDollar}rc
    fi
}

upload_files() {
    # Upload files using UA
    if [[ -f "${runtimePathConfig.getDxuaManifestFile().toString}" ]]; then
        rc=0
        ua --manifest "${runtimePathConfig.getDxuaManifestFile().toString}" >/root/ua.log 2>&1 || rc=${bashDollar}? && true

        # if there was an error during upload, print out the log
        if [[ ${bashDollar}rc != 0 ]]; then
            echo "upload agent failed rc=${bashDollar}rc"
            if [[ -f /root/ua.log ]]; then
                echo "The upload log is:"
                cat /root/ua.log
            fi
            exit ${bashDollar}rc
        fi
    fi
}

cleanup() {
    # unmount dxfuse
    if [[ -f "${runtimePathConfig.getDxfuseManifestFile().toString}" ]]; then
        echo "unmounting dxfuse"
        umount "${runtimePathConfig.getDxfuseMountDir().toString}"
    fi
}
